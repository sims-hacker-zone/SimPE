// SPDX-FileCopyrightText: Â© SimPE contributors
// SPDX-License-Identifier: GPL-2.0-or-later
using System.Collections;

using SimPe.Interfaces.Files;
using SimPe.Interfaces.Plugin;
using SimPe.PackedFiles.Mmat;

namespace SimPe.Plugin
{
	/// <summary>
	/// Creates a new Color Option package based on the passed package
	/// </summary>
	public class ColorOptions
	{
		/// <summary>
		/// The tempory new package
		/// </summary>
		//IPackageFile newpkg;

		/// <summary>
		/// The Base Package
		/// </summary>
		public IPackageFile Package
		{
			get;
		}

		/// <summary>
		/// Create a new Instance
		/// </summary>
		/// <param name="package">the source package</param>
		public ColorOptions(IPackageFile package)
		{
			Package = package;
		}

		/// <summary>
		/// Add a small Scenegraph Chain
		/// </summary>
		/// <param name="newpkg"></param>
		/// <param name="mmat">the MAterial override File for this Subset</param>
		/// <param name="txmtname">Name of the MAster TXMT</param>
		/// <param name="unique">A unique String for the Filenames</param>
		void LoadSlaveTxmt(
			IPackageFile newpkg,
			MmatWrapper mmat,
			string txmtname,
			string unique,
			Hashtable slavemap
		)
		{
			foreach (string k in slavemap.Keys)
			{
				foreach (string slave in (ArrayList)slavemap[k])
				{
					string newname = txmtname.Replace("_" + k + "_", "_" + slave + "_");
					if (newname != txmtname)
					{
						IPackedFileDescriptor[] pfds = Package.FindFile(
							newname,
							Data.FileTypes.TXMT
						);
						if (pfds.Length > 0)
						{
							AddTxmt(newpkg, mmat, new GenericRcol(null, false).ProcessFile(pfds[0], Package), null, unique, null);
						}
					}
				}
			}
		}

		/// <summary>
		/// Add a small Scenegraph Chain
		/// </summary>
		/// <param name="mmat">the MAterial override File for this Subset</param>
		/// <param name="txmt">The Material Definition File for this Subset</param>
		/// <param name="txtr">The Txtr File for this Subset (can be null)</param>
		/// <param name="unique">A unique String for the Filenames</param>
		/// <param name="slavemap">The Slavemap as generated by Scenegraph.GetSlaveSubsets() (if null, no slave txmts are loaded)</param>
		void AddTxmt(
			IPackageFile newpkg,
			MmatWrapper mmat,
			GenericRcol txmt,
			GenericRcol txtr,
			string unique,
			Hashtable slavemap
		)
		{
			//Get/Update Material Definition
			if (txmt != null)
			{
				string name = Hashes.StripHashFromName(txmt.FileName.Trim());

				//load Slave TXMTs
				if (slavemap != null)
				{
					LoadSlaveTxmt(newpkg, mmat, name, unique, slavemap);
				}

				if (name.ToLower().EndsWith("_txmt"))
				{
					name = name.Substring(0, name.Length - 5);
				}

				txmt.FileName = FixObject.GetUniqueTxmtName(
					name,
					unique,
					mmat.SubsetName,
					true
				);
				///*"##0x"+Helper.HexString(Data.MetaData.CUSTOM_GROUP)+"!"+*/name+"_"+unique+"_txmt";
				txmt.FileDescriptor = ScenegraphHelper.BuildPfd(
					txmt.FileName,
					Data.FileTypes.TXMT,
					Data.MetaData.CUSTOM_GROUP
				);

				mmat.Name =
					"##0x"
					+ Helper.HexString(txmt.FileDescriptor.Group)
					+ "!"
					+ FixObject.GetUniqueTxmtName(name, unique, mmat.SubsetName, false);

				MaterialDefinition md = (MaterialDefinition)txmt.Blocks[0];
				if (txtr == null)
				{
					txtr = mmat.GetTxtr(txmt);
					if (txtr != null)
					{
						txtr.FileDescriptor =
							txtr.FileDescriptor.Clone();
					}
				}

				//Get/Update Texture
				if (txtr != null)
				{
					name = AddTxtr(txtr, unique, txmt, md);

					md.FileDescription = Hashes.StripHashFromName(txmt.FileName).Trim();
					if (md.FileDescription.ToLower().EndsWith("_txmt"))
					{
						md.FileDescription = md.FileDescription.Substring(
							0,
							md.FileDescription.Length - 5
						);
					}
				}

				if (txtr != null)
				{
					txtr.SynchronizeUserData();
					if (newpkg.FindFile(txtr.FileDescriptor) == null)
					{
						newpkg.Add(txtr.FileDescriptor);
					}
				}

				AddReferencedTxtr(newpkg, txmt, md, unique);

				if (txmt != null)
				{
					txmt.SynchronizeUserData();
					if (newpkg.FindFile(txmt.FileDescriptor) == null)
					{
						newpkg.Add(txmt.FileDescriptor);
					}
				}
			}
		}

		protected string AddTxtr(
			GenericRcol txtr,
			string unique,
			GenericRcol txmt,
			MaterialDefinition md
		)
		{
			string old = Hashes.StripHashFromName(txtr.FileName.Trim().ToLower());
			if (old.EndsWith("_txtr"))
			{
				old = old.Substring(0, old.Length - 5);
			}
			//Console.WriteLine("Adding Texture: "+old);

			string name = txtr.FileName.Trim();
			if (name.ToLower().EndsWith("_txtr"))
			{
				name = name.Substring(0, name.Length - 5);
			}

			string tname = RenameForm.ReplaceOldUnique(name, unique, true);
			txtr.FileName = tname + "_txtr";

			txtr.FileDescriptor = ScenegraphHelper.BuildPfd(
				txtr.FileName,
				Data.FileTypes.TXTR,
				Data.MetaData.CUSTOM_GROUP
			);

			for (int i = 0; i < md.Listing.Count; i++)
			{
				if (Hashes.StripHashFromName(md.Listing[i].Trim().ToLower()) == old)
				{
					md.Listing[i] =
						"##0x"
						+ Helper.HexString(Data.MetaData.CUSTOM_GROUP)
						+ "!"
						+ tname;
				}
			}

			//update References
			foreach (string k in txmt.ReferenceChains.Keys)
			{
				if (k == "TXTR" || k == "Generic")
				{
					continue;
				}
				//Console.WriteLine("    Checking Property "+k);
				string thisname = Hashes.StripHashFromName(
					md.FindProperty(k).Value.Trim().ToLower()
				);

				if (thisname == old)
				{
					string nname =
						"##0x"
						+ Helper.HexString(Data.MetaData.CUSTOM_GROUP)
						+ "!"
						+ tname;
					//Console.WriteLine("    --> Updating to "+nname);
					md.FindProperty(k).Value = nname;
				}
			}

			//Load the Lifos into the Texture File
			ImageData id = (ImageData)txtr.Blocks[0];
			id.GetReferencedLifos();

			return name;
		}

		protected string AddTxtr(
			IPackageFile newpkg,
			GenericRcol txtr,
			string unique,
			GenericRcol txmt,
			MaterialDefinition md
		)
		{
			string name = AddTxtr(txtr, unique, txmt, md);
			txtr.SynchronizeUserData();
			if (newpkg.FindFile(txtr.FileDescriptor) == null)
			{
				newpkg.Add(txtr.FileDescriptor);
			}

			return name;
		}

		/// <summary>
		/// This adds all second Leve Textures to the Recolor (like normal Maps)
		/// </summary>
		/// <param name="newpkg"></param>
		/// <param name="md"></param>
		protected void AddReferencedTxtr(
			IPackageFile newpkg,
			GenericRcol txmt,
			MaterialDefinition md,
			string unique
		)
		{
			foreach (string k in txmt.ReferenceChains.Keys)
			{
				if (k.ToLower() == "stdmatnormalmaptexturename") //at the moment i only know of NormalMaps that need to be added
				{
					MaterialDefinitionProperty mdp = md.GetProperty(k);
					if (mdp != null)
					{
						string name = Hashes.StripHashFromName(mdp.Value).Trim();
						if (!name.EndsWith("_txtr"))
						{
							name += "_txtr";
						}

						IPackageFile pkg = txmt.Package;
						IPackedFileDescriptor[] pfds =
							pkg.FindFile(name, Data.FileTypes.TXTR);
						if (pfds.Length > 0)
						{
							AddTxtr(newpkg, new GenericRcol().ProcessFile(pfds[0], pkg), unique, txmt, md);
						}
					}
				}
			}
		}

		/// <summary>
		/// Adds the MMAT Files specified in the map to the new package
		/// </summary>
		/// <param name="newpkg"></param>
		/// <param name="map">Contains the MMATs that should be added</param>
		/// <param name="fullmap">Contains a List of all available MMATs</param>
		public void ProcessMmatMap(
			IPackageFile newpkg,
			Hashtable map,
			Hashtable fullmap
		)
		{
			if (WaitingScreen.Running)
			{
				WaitingScreen.UpdateMessage("Loading Slave Subsets");
			}

			AddSlavesSubsets(map, fullmap);
			Hashtable slaves = Scenegraph.GetSlaveSubsets(Package);

			uint inst = 0x6000;
			string unique = RenameForm.GetUniqueName(true);
			foreach (Hashtable ht in map.Values)
			{
				foreach (ArrayList list in ht.Values)
				{
					string family = System.Guid.NewGuid().ToString();
					if (unique == null)
					{
						unique = family;
					}

					foreach (MmatWrapper mmat in list)
					{
						mmat.FileDescriptor = Scenegraph.Clone(mmat.FileDescriptor);
						mmat.FileDescriptor.Instance = inst++;
						mmat.FileDescriptor.Group = Data.MetaData.LOCAL_GROUP;
						mmat.Family = family;
						mmat.DefaultMaterial = false;

						GenericRcol txmt = mmat.TXMT;
						GenericRcol txtr = mmat.TXTR;
						AddTxmt(newpkg, mmat, txmt, txtr, unique, slaves);

						mmat.SynchronizeUserData();
						newpkg.Add(mmat.FileDescriptor);
					}
				}
			}
		}

		/// <summary>
		/// Returns the first MMAT file that links to the same Texture File as the passed mmat.
		/// </summary>
		/// <param name="fullmap"></param>
		/// <param name="subset"></param>
		/// <returns></returns>
		/// <param name="mmat">If none was found, the first MMAT will be returned. Can also be null if no MMATS are available</param>
		protected ArrayList FindTxtrMatchingMmat(
			MmatWrapper mmat,
			Hashtable fullmap,
			string subset
		)
		{
			ArrayList ret = null;

			if (fullmap.ContainsKey(subset) && mmat.TXTR != null)
			{
				Hashtable ht = (Hashtable)fullmap[subset];
				foreach (ArrayList list in ht.Values)
				{
					foreach (MmatWrapper cur in list)
					{
						if (ret == null)
						{
							ret = list;
						}

						if (cur.TXTR == null)
						{
							continue;
						}

						if (mmat.TXTR.FileName == cur.TXTR.FileName)
						{
							return list;
						}
					}
				}
			}
			return ret;
		}

		/// <summary>
		/// Adds the SlaveSubsets to the map
		/// </summary>
		/// <param name="map">Contains the MMATs that should be added</param>
		/// <param name="fullmap">Contains a List of all available MMATs</param>
		/// <remarks>The slave MMAT files will be added to the map</remarks>
		protected void AddSlavesSubsets(Hashtable map, Hashtable fullmap)
		{
			Hashtable slavemap = Scenegraph.GetSlaveSubsets(Package);
			Hashtable newmap = new Hashtable();

			int ct = 0;
			foreach (string k in map.Keys)
			{
				if (!fullmap.ContainsKey(k))
				{
					if (slavemap.ContainsKey(k))
					{
						if (map.ContainsKey(k))
						{
							ArrayList slaves = (ArrayList)slavemap[k];
							Hashtable families = (Hashtable)map[k];
							foreach (ArrayList list in families.Values)
							{
								foreach (MmatWrapper mmat in list)
								{
									foreach (string subset in slaves)
									{
										ArrayList slavemmat = FindTxtrMatchingMmat(
											mmat,
											fullmap,
											subset
										);
										if (slavemmat != null)
										{
											Hashtable slaveht = new Hashtable
											{
												[
												"simpe_slave_loader_"
													+ subset
													+ "-"
													+ ct.ToString()
											] = slavemmat
											};
											newmap[subset] = slaveht;
											ct++;
										}
									} //foreach subset
								} //foreach mmat
							} //foreach list
						} //if (map.ContainsKey(k))
					}
				}
			}

			Hashtable nmap = new Hashtable();
			foreach (string k in newmap.Keys)
			{
				if (!map.ContainsKey(k))
				{
					nmap[k] = newmap[k];
				}
			}

			if (newmap.Count > 0)
			{
				AddSlavesSubsets(nmap, fullmap);
			}

			foreach (string k in nmap.Keys)
			{
				map[k] = nmap[k];
			}
		}

		public delegate void CreateSelectionCallback(
			SubsetSelectForm ssf,
			bool userselect,
			Hashtable fullmap
		);

		/// <summary>
		/// Create a new Color Options package
		/// </summary>
		/// <param name="newpkg">The Package the color Option should be added to</param>
		/// <param name="ask">if ask is true, a Dialog will be displayed that lets the
		/// user decide which Subsets to recolor</param>
		public void Create(IPackageFile newpkg)
		{
			WaitingScreen.Wait();
			try
			{
				//this.newpkg = newpkg;

				WaitingScreen.UpdateMessage("Loading available Color Options");
				Hashtable fullmap = Scenegraph.GetMMATMap(Package);
				Hashtable map = fullmap;
				ArrayList allowedSubsets = Scenegraph.GetRecolorableSubsets(Package);

				//Check if the User can select a Subset
				bool userselect = false;
				if (map.Count > 1)
				{
					userselect = true;
				}
				else
				{
					if (map.Count == 1)
					{
						foreach (string s in map.Keys)
						{
							Hashtable ht = (Hashtable)map[s];
							if (ht.Count > 1)
							{
								userselect = true;
							}
						}
					}
				}

				//let the user Select now
				if (userselect)
				{
					map = SubsetSelectForm.Execute(map, allowedSubsets);
				}

				ProcessMmatMap(newpkg, map, fullmap);
			}
			finally
			{
				WaitingScreen.Stop();
			}
		}

		/// <summary>
		/// Create a new Color Options package
		/// </summary>
		/// <param name="newpkg">The Package the color Option should be added to</param>
		/// <param name="fkt">The function that ahs to be called wne the Selection should be displayed</param>
		public void Create(IPackageFile newpkg, CreateSelectionCallback fkt)
		{
			WaitingScreen.Wait();
			try
			{
				//this.newpkg = newpkg;

				WaitingScreen.UpdateMessage("Loading available Color Options");
				Hashtable fullmap = Scenegraph.GetMMATMap(Package);
				Hashtable map = fullmap;
				ArrayList allowedSubsets = Scenegraph.GetRecolorableSubsets(Package);

				//Check if the User can select a Subset
				bool userselect = false;
				if (map.Count > 1)
				{
					userselect = true;
				}
				else
				{
					if (map.Count == 1)
					{
						foreach (string s in map.Keys)
						{
							Hashtable ht = (Hashtable)map[s];
							if (ht.Count > 1)
							{
								userselect = true;
							}
						}
					}
				}

				SubsetSelectForm ssf = SubsetSelectForm.Prepare(map, allowedSubsets);
				fkt(ssf, userselect, fullmap);
			}
			finally
			{
				WaitingScreen.Stop();
			}
			return;
			/*string[] subsets = GetSubsets();

			//let the user Select
			if ((subsets.Length>1) && (ask))
			{
				Listing l = new Listing();
				subsets = l.Execute(subsets);
			}

			WaitingScreen.Wait();
			WaitingScreen.UpdateMessage("Getting slave Subsets");
			SubsetItem[] subsetsi = GetSlaveSubsets(subsets);

			WaitingScreen.UpdateMessage("Getting Resource Nodes");
			ArrayList cres = GetCresNames(subsetsi);

			WaitingScreen.UpdateMessage("Getting Material Overrides");
			Hashtable mmats = GetMMATs(subsetsi, cres);
			ArrayList guids = GetGUIDs();

			LoadSubSetList(mmats, guids, subsetsi);

			WaitingScreen.UpdateMessage("Load LIFO Files");
			GetLifoFiles();

			WaitingScreen.Stop();*/
		}
	}
}
